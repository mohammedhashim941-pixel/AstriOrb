import{r as e,j as n}from"./index-BWTBxtVk.js";import{W as t,V as o,C as i,S as a,O as r,a as l,G as s,P as u,M as c,E as f,R as d,b as m,c as p,U as v,d as h,T as x,L as g}from"./vendor-three-GrAzJwRx.js";import"./vendor-react-CdFD_Q2s.js";const w=(e=!1)=>{const n=e?32:64,t=document.createElement("canvas");t.width=n,t.height=n;const o=t.getContext("2d");if(!o)throw new Error("2D context not available");o.fillStyle="black",o.fillRect(0,0,t.width,t.height);const i=new x(t);i.minFilter=g,i.magFilter=g,i.generateMipmaps=!1;const a=[];let r=null;const l=64;let s=.1*n;const u=e=>{const t=e.x*n,i=(1-e.y)*n;let a=1;var r;e.age<19.2?(r=e.age/19.2,a=Math.sin(r*Math.PI/2)):a=(e=>-e*(e-2))(1-(e.age-19.2)/44.8)||0,a*=e.force;const l=`${(e.vx+1)/2*255}, ${(e.vy+1)/2*255}, ${255*a}`,u=5*n;o.shadowOffsetX=u,o.shadowOffsetY=u,o.shadowBlur=s,o.shadowColor=`rgba(${l},${.22*a})`,o.beginPath(),o.fillStyle="rgba(255,0,0,1)",o.arc(t-u,i-u,s,0,2*Math.PI),o.fill()};return{canvas:t,texture:i,addTouch:e=>{let n=0,t=0,o=0;if(r){const i=e.x-r.x,a=e.y-r.y;if(0===i&&0===a)return;const l=i*i+a*a,s=Math.sqrt(l);t=i/(s||1),o=a/(s||1),n=Math.min(1e4*l,1)}r={x:e.x,y:e.y},a.push({x:e.x,y:e.y,age:0,force:n,vx:t,vy:o})},update:()=>{o.fillStyle="black",o.fillRect(0,0,t.width,t.height);for(let e=a.length-1;e>=0;e--){const n=a[e],t=.015625*n.force*(1-n.age/l);n.x+=n.vx*t,n.y+=n.vy*t,n.age++,n.age>l&&a.splice(e,1)}for(let e=0;e<a.length;e++)u(a[e]);i.needsUpdate=!0},set radiusScale(e){s=.1*n*e},get radiusScale(){return s/(.1*n)},size:n}},y={square:0,circle:1,triangle:2,diamond:3},S=({variant:x="square",pixelSize:g=3,color:S="#B19EEF",className:E,style:R,antialias:C=!0,patternScale:T=2,patternDensity:b=1,liquid:P=!1,liquidStrength:A=.1,liquidRadius:M=1,pixelSizeJitter:I=0,enableRipples:k=!0,rippleIntensityScale:q=1,rippleThickness:z=.1,rippleSpeed:F=.3,liquidWobbleSpeed:B=4.5,autoPauseOffscreen:_=!0,speed:D=.5,transparent:L=!0,edgeFade:U=.5,noiseAmount:O=0})=>{const N=e.useRef(null),G=e.useRef({visible:!0}),H=e.useRef(D),V=e.useRef(null),j=e.useRef(null);return e.useEffect(()=>{const e=N.current;if(!e)return;H.current=D;const n=["antialias","liquid","noiseAmount"],E={antialias:C,liquid:P,noiseAmount:O};let R=!1;if(V.current){if(j.current)for(const t of n)if(j.current[t]!==E[t]){R=!0;break}}else R=!0;if(R){if(V.current){const n=V.current;n.resizeObserver?.disconnect(),cancelAnimationFrame(n.raf),n.quad?.geometry.dispose(),n.material.dispose(),n.composer?.dispose(),n.renderer.dispose(),n.renderer.domElement.parentElement===e&&e.removeChild(n.renderer.domElement),V.current=null}const n=document.createElement("canvas"),E="undefined"!=typeof navigator&&(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||window.innerWidth<=768),R=new t({canvas:n,antialias:!E&&C,alpha:!0,powerPreference:E?"low-power":"high-performance"});R.domElement.style.width="100%",R.domElement.style.height="100%",R.setPixelRatio(E?1:Math.min(window.devicePixelRatio||1,2)),e.appendChild(R.domElement),L?R.setClearAlpha(0):R.setClearColor(0,1);const D={uResolution:{value:new o(0,0)},uTime:{value:0},uColor:{value:new i(S)},uClickPos:{value:Array.from({length:10},()=>new o(-1,-1))},uClickTimes:{value:new Float32Array(10)},uShapeType:{value:y[x]??0},uPixelSize:{value:g*R.getPixelRatio()},uScale:{value:T},uDensity:{value:b},uPixelJitter:{value:I},uEnableRipples:{value:k?1:0},uRippleSpeed:{value:F},uRippleThickness:{value:z},uRippleIntensity:{value:q},uIsMobile:{value:E?1:0},uEdgeFade:{value:U}},N=new a,j=new r(-1,1,1,-1,0,1),J=new l({vertexShader:"\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n",fragmentShader:"\nprecision highp float;\n\nuniform vec3  uColor;\nuniform vec2  uResolution;\nuniform float uTime;\nuniform float uPixelSize;\nuniform float uScale;\nuniform float uDensity;\nuniform float uPixelJitter;\nuniform int   uEnableRipples;\nuniform float uRippleSpeed;\nuniform float uRippleThickness;\nuniform float uRippleIntensity;\nuniform float uEdgeFade;\nuniform int   uIsMobile;\n\nuniform int   uShapeType;\nconst int SHAPE_SQUARE   = 0;\nconst int SHAPE_CIRCLE   = 1;\nconst int SHAPE_TRIANGLE = 2;\nconst int SHAPE_DIAMOND  = 3;\n\nconst int   MAX_CLICKS = 10;\n\nuniform vec2  uClickPos  [MAX_CLICKS];\nuniform float uClickTimes[MAX_CLICKS];\n\nout vec4 fragColor;\n\nfloat Bayer2(vec2 a) {\n  a = floor(a);\n  return fract(a.x / 2. + a.y * a.y * .75);\n}\n#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))\n#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))\n\n// Dynamic FBM octaves - fewer on mobile for performance\n#define FBM_LACUNARITY  1.25\n#define FBM_GAIN        1.0\n\nfloat hash11(float n){ return fract(sin(n)*43758.5453); }\n\nfloat vnoise(vec3 p){\n  vec3 ip = floor(p);\n  vec3 fp = fract(p);\n  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));\n  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));\n  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));\n  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));\n  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\n  float x00 = mix(n000, n100, w.x);\n  float x10 = mix(n010, n110, w.x);\n  float x01 = mix(n001, n101, w.x);\n  float x11 = mix(n011, n111, w.x);\n  float y0  = mix(x00, x10, w.y);\n  float y1  = mix(x01, x11, w.y);\n  return mix(y0, y1, w.z) * 2.0 - 1.0;\n}\n\nfloat fbm2(vec2 uv, float t){\n  vec3 p = vec3(uv * uScale, t);\n  float amp = 1.0;\n  float freq = 1.0;\n  float sum = 1.0;\n  // Use 3 octaves on mobile, 5 on desktop for ~40% GPU savings\n  int octaves = uIsMobile == 1 ? 3 : 5;\n  for (int i = 0; i < 5; ++i){\n    if (i >= octaves) break;\n    sum  += amp * vnoise(p * freq);\n    freq *= FBM_LACUNARITY;\n    amp  *= FBM_GAIN;\n  }\n  return sum * 0.5 + 0.5;\n}\n\nfloat maskCircle(vec2 p, float cov){\n  float r = sqrt(cov) * .25;\n  float d = length(p - 0.5) - r;\n  float aa = 0.5 * fwidth(d);\n  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\n}\n\nfloat maskTriangle(vec2 p, vec2 id, float cov){\n  bool flip = mod(id.x + id.y, 2.0) > 0.5;\n  if (flip) p.x = 1.0 - p.x;\n  float r = sqrt(cov);\n  float d  = p.y - r*(1.0 - p.x);\n  float aa = fwidth(d);\n  return cov * clamp(0.5 - d/aa, 0.0, 1.0);\n}\n\nfloat maskDiamond(vec2 p, float cov){\n  float r = sqrt(cov) * 0.564;\n  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\n}\n\nvoid main(){\n  float pixelSize = uPixelSize;\n  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;\n  float aspectRatio = uResolution.x / uResolution.y;\n\n  vec2 pixelId = floor(fragCoord / pixelSize);\n  vec2 pixelUV = fract(fragCoord / pixelSize);\n\n  float cellPixelSize = 8.0 * pixelSize;\n  vec2 cellId = floor(fragCoord / cellPixelSize);\n  vec2 cellCoord = cellId * cellPixelSize;\n  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\n\n  float base = fbm2(uv, uTime * 0.05);\n  base = base * 0.5 - 0.65;\n\n  float feed = base + (uDensity - 0.5) * 0.3;\n\n  float speed     = uRippleSpeed;\n  float thickness = uRippleThickness;\n  const float dampT     = 1.0;\n  const float dampR     = 10.0;\n\n  if (uEnableRipples == 1) {\n    for (int i = 0; i < MAX_CLICKS; ++i){\n      vec2 pos = uClickPos[i];\n      if (pos.x < 0.0) continue;\n      float cellPixelSize = 8.0 * pixelSize;\n      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);\n      float t = max(uTime - uClickTimes[i], 0.0);\n      float r = distance(uv, cuv);\n      float waveR = speed * t;\n      float ring  = exp(-pow((r - waveR) / thickness, 2.0));\n      float atten = exp(-dampT * t) * exp(-dampR * r);\n      feed = max(feed, ring * atten * uRippleIntensity);\n    }\n  }\n\n  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;\n  float bw = step(0.5, feed + bayer);\n\n  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);\n  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;\n  float coverage = bw * jitterScale;\n  float M;\n  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);\n  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);\n  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);\n  else                                   M = coverage;\n\n  if (uEdgeFade > 0.0) {\n    vec2 norm = gl_FragCoord.xy / uResolution;\n    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\n    float fade = smoothstep(0.0, uEdgeFade, edge);\n    M *= fade;\n  }\n\n  vec3 color = uColor;\n\n  // sRGB gamma correction - convert linear to sRGB for accurate color output\n  vec3 srgbColor = mix(\n    color * 12.92,\n    1.055 * pow(color, vec3(1.0 / 2.4)) - 0.055,\n    step(0.0031308, color)\n  );\n\n  fragColor = vec4(srgbColor, M);\n}\n",uniforms:D,transparent:!0,depthTest:!1,depthWrite:!1,glslVersion:s}),W=new u(2,2),K=new c(W,J);N.add(K);const Y=new h,Q=()=>{const n=e.clientWidth||1,t=e.clientHeight||1;R.setSize(n,t,!1),D.uResolution.value.set(R.domElement.width,R.domElement.height),V.current?.composer&&V.current.composer.setSize(R.domElement.width,R.domElement.height),D.uPixelSize.value=g*R.getPixelRatio()};Q();const Z=new ResizeObserver(Q);Z.observe(e);const ee=1e3*(()=>{if("undefined"!=typeof window&&window.crypto?.getRandomValues){const e=new Uint32Array(1);return window.crypto.getRandomValues(e),e[0]/4294967295}return Math.random()})();let ne,te,oe;if(P){te=w(E),te.radiusScale=M,ne=new f(R);const e=new d(N,j);X=te.texture,$={strength:A,freq:B},oe=new p("LiquidEffect","\n    uniform sampler2D uTexture;\n    uniform float uStrength;\n    uniform float uTime;\n    uniform float uFreq;\n\n    void mainUv(inout vec2 uv) {\n      vec4 tex = texture2D(uTexture, uv);\n      float vx = tex.r * 2.0 - 1.0;\n      float vy = tex.g * 2.0 - 1.0;\n      float intensity = tex.b;\n\n      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);\n\n      float amt = uStrength * intensity * wave;\n\n      uv += vec2(vx, vy) * amt;\n    }\n    ",{uniforms:new Map([["uTexture",new v(X)],["uStrength",new v($?.strength??.025)],["uTime",new v(0)],["uFreq",new v($?.freq??4.5)]])});const n=new m(j,oe);n.renderToScreen=!0,ne.addPass(e),ne.addPass(n)}if(O>0){ne||(ne=new f(R),ne.addPass(new d(N,j)));const e=new p("NoiseEffect","uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} ",{uniforms:new Map([["uTime",new v(0)],["uAmount",new v(O)]])}),n=new m(j,e);n.renderToScreen=!0,ne&&ne.passes.length>0&&ne.passes.forEach(e=>e.renderToScreen=!1),ne.addPass(n)}ne&&ne.setSize(R.domElement.width,R.domElement.height);const ie=e=>{const n=R.domElement.getBoundingClientRect(),t=R.domElement.width/n.width,o=R.domElement.height/n.height;return{fx:(e.clientX-n.left)*t,fy:(n.height-(e.clientY-n.top))*o,w:R.domElement.width,h:R.domElement.height}},ae=e=>{const{fx:n,fy:t}=ie(e),o=V.current?.clickIx??0;D.uClickPos.value[o].set(n,t),D.uClickTimes.value[o]=D.uTime.value,V.current&&(V.current.clickIx=(o+1)%10)},re=e=>{if(!te)return;const{fx:n,fy:t,w:o,h:i}=ie(e);te.addTouch({x:n/o,y:t/i})};R.domElement.addEventListener("pointerdown",ae,{passive:!0}),R.domElement.addEventListener("pointermove",re,{passive:!0});let le=0;const se=()=>{!_||G.current.visible?(D.uTime.value=ee+Y.getElapsedTime()*H.current,oe&&(oe.uniforms.get("uTime").value=D.uTime.value),ne?(te&&te.update(),ne.passes.forEach(e=>{const n=e.effects;n&&n.forEach(e=>{const n=e.uniforms?.get("uTime");n&&(n.value=D.uTime.value)})}),ne.render()):R.render(N,j),le=requestAnimationFrame(se)):le=requestAnimationFrame(se)};le=requestAnimationFrame(se),V.current={renderer:R,scene:N,camera:j,material:J,clock:Y,clickIx:0,uniforms:D,resizeObserver:Z,raf:le,quad:K,timeOffset:ee,composer:ne,touch:te,liquidEffect:oe}}else{const e=V.current;if(e.uniforms.uShapeType.value=y[x]??0,e.uniforms.uPixelSize.value=g*e.renderer.getPixelRatio(),e.uniforms.uColor.value.set(S),e.uniforms.uScale.value=T,e.uniforms.uDensity.value=b,e.uniforms.uPixelJitter.value=I,e.uniforms.uEnableRipples.value=k?1:0,e.uniforms.uRippleIntensity.value=q,e.uniforms.uRippleThickness.value=z,e.uniforms.uRippleSpeed.value=F,e.uniforms.uEdgeFade.value=U,L?e.renderer.setClearAlpha(0):e.renderer.setClearColor(0,1),e.liquidEffect){const n=e.liquidEffect;n&&(n.value=A);const t=e.liquidEffect.uniforms.get("uFreq");t&&(t.value=B)}e.touch&&(e.touch.radiusScale=M)}var X,$;return j.current=E,()=>{if(V.current&&R)return;if(!V.current)return;const n=V.current;n.resizeObserver?.disconnect(),cancelAnimationFrame(n.raf),n.quad?.geometry.dispose(),n.material.dispose(),n.composer?.dispose(),n.renderer.dispose(),n.renderer.domElement.parentElement===e&&e.removeChild(n.renderer.domElement),V.current=null}},[C,P,O,g,T,b,k,q,z,F,I,U,L,A,M,B,_,x,S,D]),n.jsx("div",{ref:N,className:`pixel-blast-container ${E??""}`,style:R,"aria-label":"PixelBlast interactive background"})};export{S as default};
